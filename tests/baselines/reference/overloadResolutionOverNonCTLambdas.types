//// [tests/cases/compiler/overloadResolutionOverNonCTLambdas.ts] ////

=== overloadResolutionOverNonCTLambdas.ts ===
module Bugs {
>Bugs : typeof Bugs
>     : ^^^^^^^^^^^

  class A {
>A : A
>  : ^
  }
  
  // replace(searchValue: RegExp, replaceValue: (substring: string, ...args: any[]) => string): string;
  function bug2(message:string, ...args:any[]):string {
>bug2 : (message: string, ...args: any[]) => string
>     : ^       ^^      ^^^^^    ^^     ^^^^^      
>message : string
>        : ^^^^^^
>args : any[]
>     : ^^^^^

    var result= message.replace(/\{(\d+)\}/g, function(match, ...rest) {
>result : string
>       : ^^^^^^
>message.replace(/\{(\d+)\}/g, function(match, ...rest) {      var index= rest[0];      return typeof args[index] !== 'undefined'        ? args[index]        : match;    }) : string
>                                                                                                                                                                            : ^^^^^^
>message.replace : { <T extends string>(searchValue: T, replaceValue: string | StringReplaceCallbackSignature<[searchValue: T], undefined>): string; <CapturingGroups extends CapturingGroupsArray = CapturingGroupsArray, NamedCapturingGroups extends NamedCapturingGroupsObject = { [name: string]: string; }>(searchValue: string | RegExp<CapturingGroups, NamedCapturingGroups>, replaceValue: string | StringReplaceCallbackSignature<CapturingGroups, NamedCapturingGroups>): string; }
>                : ^^^ ^^^^^^^^^      ^^           ^^ ^^            ^^                                                                    ^^^      ^^^               ^^^^^^^^^                    ^^^^^^^^^^^^^^^^^^^^^^^^^                    ^^^^^^^^^                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^           ^^                                                      ^^            ^^                                                                              ^^^      ^^^
>message : string
>        : ^^^^^^
>replace : { <T extends string>(searchValue: T, replaceValue: string | StringReplaceCallbackSignature<[searchValue: T], undefined>): string; <CapturingGroups extends CapturingGroupsArray = CapturingGroupsArray, NamedCapturingGroups extends NamedCapturingGroupsObject = { [name: string]: string; }>(searchValue: string | RegExp<CapturingGroups, NamedCapturingGroups>, replaceValue: string | StringReplaceCallbackSignature<CapturingGroups, NamedCapturingGroups>): string; }
>        : ^^^ ^^^^^^^^^      ^^           ^^ ^^            ^^                                                                    ^^^      ^^^               ^^^^^^^^^                    ^^^^^^^^^^^^^^^^^^^^^^^^^                    ^^^^^^^^^                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^           ^^                                                      ^^            ^^                                                                              ^^^      ^^^
>/\{(\d+)\}/g : RegExp<[`{${string}}`, string], undefined, { hasIndices: false; global: true; ignoreCase: false; multiline: false; dotAll: false; unicode: false; unicodeSets: false; sticky: false; }>
>             : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>function(match, ...rest) {      var index= rest[0];      return typeof args[index] !== 'undefined'        ? args[index]        : match;    } : (match: `{${string}}`, rest_0: string, index: number, input: `${string}{${string}}${string}`) => any
>                                                                                                                                             : ^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>match : `{${string}}`
>      : ^^^^^^^^^^^^^
>rest : [string, index: number, input: `${string}{${string}}${string}`]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

      var index= rest[0];
>index : string
>      : ^^^^^^
>rest[0] : string
>        : ^^^^^^
>rest : [string, index: number, input: `${string}{${string}}${string}`]
>     : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>0 : 0
>  : ^

      return typeof args[index] !== 'undefined'
>typeof args[index] !== 'undefined'        ? args[index]        : match : error
>typeof args[index] !== 'undefined' : boolean
>                                   : ^^^^^^^
>typeof args[index] : "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"
>                   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
>args[index] : error
>args : any[]
>     : ^^^^^
>index : string
>      : ^^^^^^
>'undefined' : "undefined"
>            : ^^^^^^^^^^^

        ? args[index]
>args[index] : error
>args : any[]
>     : ^^^^^
>index : string
>      : ^^^^^^

        : match;
>match : `{${string}}`
>      : ^^^^^^^^^^^^^

    });
    return result;
>result : string
>       : ^^^^^^
  }
}

function bug3(f:(x:string)=>string) { return f("s") }
>bug3 : (f: (x: string) => string) => string
>     : ^ ^^                     ^^^^^^^^^^^
>f : (x: string) => string
>  : ^ ^^      ^^^^^      
>x : string
>  : ^^^^^^
>f("s") : string
>       : ^^^^^^
>f : (x: string) => string
>  : ^ ^^      ^^^^^      
>"s" : "s"
>    : ^^^

function fprime(x:string):string { return x; }
>fprime : (x: string) => string
>       : ^ ^^      ^^^^^      
>x : string
>  : ^^^^^^
>x : string
>  : ^^^^^^

bug3(fprime);
>bug3(fprime) : string
>             : ^^^^^^
>bug3 : (f: (x: string) => string) => string
>     : ^ ^^                     ^^^^^^^^^^^
>fprime : (x: string) => string
>       : ^ ^^      ^^^^^      

bug3(function(x:string):string { return x; });
>bug3(function(x:string):string { return x; }) : string
>                                              : ^^^^^^
>bug3 : (f: (x: string) => string) => string
>     : ^ ^^                     ^^^^^^^^^^^
>function(x:string):string { return x; } : (x: string) => string
>                                        : ^ ^^      ^^^^^      
>x : string
>  : ^^^^^^
>x : string
>  : ^^^^^^

