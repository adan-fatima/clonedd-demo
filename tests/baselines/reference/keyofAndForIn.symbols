//// [tests/cases/conformance/types/keyof/keyofAndForIn.ts] ////

=== keyofAndForIn.ts ===
function f1<K extends string, T>(obj: { [P in K]: T }, k: K) {
>f1 : Symbol(f1, Decl(keyofAndForIn.ts, 0, 0))
>K : Symbol(K, Decl(keyofAndForIn.ts, 0, 12))
>T : Symbol(T, Decl(keyofAndForIn.ts, 0, 29))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 0, 33))
>P : Symbol(P, Decl(keyofAndForIn.ts, 0, 41))
>K : Symbol(K, Decl(keyofAndForIn.ts, 0, 12))
>T : Symbol(T, Decl(keyofAndForIn.ts, 0, 29))
>k : Symbol(k, Decl(keyofAndForIn.ts, 0, 54))
>K : Symbol(K, Decl(keyofAndForIn.ts, 0, 12))

    const b = k in obj;
>b : Symbol(b, Decl(keyofAndForIn.ts, 1, 9))
>k : Symbol(k, Decl(keyofAndForIn.ts, 0, 54))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 0, 33))

    let k1: K;
>k1 : Symbol(k1, Decl(keyofAndForIn.ts, 2, 7))
>K : Symbol(K, Decl(keyofAndForIn.ts, 0, 12))

    for (k1 in obj) {
>k1 : Symbol(k1, Decl(keyofAndForIn.ts, 2, 7))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 0, 33))

        let x1 = obj[k1];
>x1 : Symbol(x1, Decl(keyofAndForIn.ts, 4, 11))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 0, 33))
>k1 : Symbol(k1, Decl(keyofAndForIn.ts, 2, 7))
    }
    for (let k2 in obj) {
>k2 : Symbol(k2, Decl(keyofAndForIn.ts, 6, 12))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 0, 33))

        let x2 = obj[k2];
>x2 : Symbol(x2, Decl(keyofAndForIn.ts, 7, 11))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 0, 33))
>k2 : Symbol(k2, Decl(keyofAndForIn.ts, 6, 12))
    }
}

function f2<T>(obj: { [P in keyof T]: T[P] }, k: keyof T) {
>f2 : Symbol(f2, Decl(keyofAndForIn.ts, 9, 1))
>T : Symbol(T, Decl(keyofAndForIn.ts, 11, 12))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 11, 15))
>P : Symbol(P, Decl(keyofAndForIn.ts, 11, 23))
>T : Symbol(T, Decl(keyofAndForIn.ts, 11, 12))
>T : Symbol(T, Decl(keyofAndForIn.ts, 11, 12))
>P : Symbol(P, Decl(keyofAndForIn.ts, 11, 23))
>k : Symbol(k, Decl(keyofAndForIn.ts, 11, 45))
>T : Symbol(T, Decl(keyofAndForIn.ts, 11, 12))

    const b = k in obj;
>b : Symbol(b, Decl(keyofAndForIn.ts, 12, 9))
>k : Symbol(k, Decl(keyofAndForIn.ts, 11, 45))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 11, 15))

    let k1: keyof T;
>k1 : Symbol(k1, Decl(keyofAndForIn.ts, 13, 7))
>T : Symbol(T, Decl(keyofAndForIn.ts, 11, 12))

    for (k1 in obj) {
>k1 : Symbol(k1, Decl(keyofAndForIn.ts, 13, 7))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 11, 15))

        let x1 = obj[k1];
>x1 : Symbol(x1, Decl(keyofAndForIn.ts, 15, 11))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 11, 15))
>k1 : Symbol(k1, Decl(keyofAndForIn.ts, 13, 7))
    }
    for (let k2 in obj) {
>k2 : Symbol(k2, Decl(keyofAndForIn.ts, 17, 12))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 11, 15))

        let x2 = obj[k2];
>x2 : Symbol(x2, Decl(keyofAndForIn.ts, 18, 11))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 11, 15))
>k2 : Symbol(k2, Decl(keyofAndForIn.ts, 17, 12))
    }
}

function f3<T, K extends keyof T>(obj: { [P in K]: T[P] }, k: K) {
>f3 : Symbol(f3, Decl(keyofAndForIn.ts, 20, 1))
>T : Symbol(T, Decl(keyofAndForIn.ts, 22, 12))
>K : Symbol(K, Decl(keyofAndForIn.ts, 22, 14))
>T : Symbol(T, Decl(keyofAndForIn.ts, 22, 12))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 22, 34))
>P : Symbol(P, Decl(keyofAndForIn.ts, 22, 42))
>K : Symbol(K, Decl(keyofAndForIn.ts, 22, 14))
>T : Symbol(T, Decl(keyofAndForIn.ts, 22, 12))
>P : Symbol(P, Decl(keyofAndForIn.ts, 22, 42))
>k : Symbol(k, Decl(keyofAndForIn.ts, 22, 58))
>K : Symbol(K, Decl(keyofAndForIn.ts, 22, 14))

    const b = k in obj;
>b : Symbol(b, Decl(keyofAndForIn.ts, 23, 9))
>k : Symbol(k, Decl(keyofAndForIn.ts, 22, 58))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 22, 34))

    let k1: K;
>k1 : Symbol(k1, Decl(keyofAndForIn.ts, 24, 7))
>K : Symbol(K, Decl(keyofAndForIn.ts, 22, 14))

    for (k1 in obj) {
>k1 : Symbol(k1, Decl(keyofAndForIn.ts, 24, 7))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 22, 34))

        let x1 = obj[k1];
>x1 : Symbol(x1, Decl(keyofAndForIn.ts, 26, 11))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 22, 34))
>k1 : Symbol(k1, Decl(keyofAndForIn.ts, 24, 7))
    }
    for (let k2 in obj) {
>k2 : Symbol(k2, Decl(keyofAndForIn.ts, 28, 12))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 22, 34))

        let x2 = obj[k2];
>x2 : Symbol(x2, Decl(keyofAndForIn.ts, 29, 11))
>obj : Symbol(obj, Decl(keyofAndForIn.ts, 22, 34))
>k2 : Symbol(k2, Decl(keyofAndForIn.ts, 28, 12))
    }
}
